<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>surface (catala.surface)</title><link rel="stylesheet" href="../_odoc_support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../_odoc_support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="index.html">catala</a> &#x00BB; surface</nav><header class="odoc-preamble"><h1 id="catala-surface-representation"><a href="#catala-surface-representation" class="anchor"></a>Catala surface representation</h1><p>This representation is the first in the compilation chain (see <a href="index.html#architecture">Architecture</a>). Its purpose is to host the output of the Catala parser, before any transformations have been made.</p><p>The module describing the abstract syntax tree is:</p><ul class="modules"><li><a href="Surface/Ast/index.html"><code>Surface.Ast</code></a> <span class="synopsis">Abstract syntax tree built by the Catala parser</span></li></ul><p>This representation can also be weaved into literate programming outputs using the <a href="literate.html">literate programming modules</a>.</p></header><nav class="odoc-toc"><ul><li><a href="#lexing">Lexing</a></li><li><a href="#parsing">Parsing</a></li><li><a href="#name-resolution-and-translation">Name resolution and translation</a></li></ul></nav><div class="odoc-content"><h2 id="lexing"><a href="#lexing" class="anchor"></a>Lexing</h2><p>The lexing in the Catala compiler is done using <a href="https://github.com/ocaml-community/sedlex">sedlex</a>, the modern OCaml lexer that offers full support for UTF-8. This support enables users of non-English languages to use their favorite diacritics and symbols in their code.</p><p>While the parser of Catala is unique, three different lexers can be used to produce the parser tokens.</p><ul><li><a href="Surface/Lexer_common/index.html"><code>Surface.Lexer_common</code></a> corresponds to a concise and programming-language-like syntax for Catala. Examples of this syntax can be found in the test suite of the compiler.</li><li><a href="Surface/Lexer_en/index.html"><code>Surface.Lexer_en</code></a> is the adaptation of <a href="Surface/Lexer_common/index.html"><code>Surface.Lexer_common</code></a> with verbose English keywords matching legal concepts.</li><li><a href="Surface/Lexer_fr/index.html"><code>Surface.Lexer_fr</code></a> is the adaptation of <a href="Surface/Lexer_common/index.html"><code>Surface.Lexer_common</code></a> with verbose French keywords matching legal concepts.</li></ul><p>Relevant modules:</p><ul class="modules"><li><a href="Surface/Lexer_common/index.html"><code>Surface.Lexer_common</code></a> <span class="synopsis">Auxiliary functions used by all lexers.</span></li><li><a href="Surface/Lexer_fr/index.html"><code>Surface.Lexer_fr</code></a> </li><li><a href="Surface/Lexer_en/index.html"><code>Surface.Lexer_en</code></a> </li></ul><h2 id="parsing"><a href="#parsing" class="anchor"></a>Parsing</h2><p>The Catala compiler uses <a href="http://cambium.inria.fr/~fpottier/menhir/">Menhir</a> to perform its parsing.</p><p><a href="Surface/Parser/index.html"><code>Surface.Parser</code></a> is the main file where the parser tokens and the grammar is declared. It is automatically translated into its parsing automata equivalent by Menhir.</p><p>In order to provide decent syntax error messages, the Catala compiler uses the novel error handling provided by Menhir and detailed in Section 11 of the <a href="http://cambium.inria.fr/~fpottier/menhir/manual.pdf">Menhir manual</a>.</p><p>A <code>parser.messages</code> source file has been manually annotated with custom error message for every potential erroneous state of the parser, and Menhir automatically generated the <a href="Surface/Parser_errors/index.html"><code>Surface.Parser_errors</code></a> module containing the function linking the erroneous parser states to the custom error message.</p><p>To wrap it up, <a href="Surface/Parser_driver/index.html"><code>Surface.Parser_driver</code></a> glues all the parsing and lexing together to perform the translation from source code to abstract syntax tree, with meaningful error messages.</p><p>Relevant modules:</p><ul class="modules"><li><a href="Surface/Parser/index.html"><code>Surface.Parser</code></a> </li><li><a href="Surface/Parser_driver/index.html"><code>Surface.Parser_driver</code></a> <span class="synopsis">Wrapping module around parser and lexer that offers the <code>Surface.Parser_driver.parse_source_file</code> API.</span></li><li><a href="Surface/Parser_errors/index.html"><code>Surface.Parser_errors</code></a> <span class="synopsis">Interface of the module auto-generated based on &quot;parser.messages&quot;.</span></li></ul><h2 id="name-resolution-and-translation"><a href="#name-resolution-and-translation" class="anchor"></a>Name resolution and translation</h2><p>The desugaring consists of translating <a href="Surface/Ast/index.html"><code>Surface.Ast</code></a> to <a href="Desugared/Ast/index.html"><code>Desugared.Ast</code></a> of the <a href="desugared.html">desugared representation</a>. The translation is implemented in <code>Surface</code>.Desugaring, but it relies on a helper module to perform the name resolution: <code>Surface</code>.Name_resolution. Indeed, in <a href="Surface/Ast/index.html"><code>Surface.Ast</code></a>, the variables identifiers are just <code>string</code>, whereas in <a href="Desugared/Ast/index.html"><code>Desugared.Ast</code></a> they have been turned into well-categorized types with an unique identifier like <code>Scopelang</code>.Ast.ScopeName.t.</p><p>Relevant modules:</p><ul class="modules"><li><code>Surface</code>.Name_resolution </li><li><code>Surface</code>.Desugaring </li></ul></div></body></html>